---
title: "Clase 6 - Visualización de gráficos e iteraciones"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
author: "Carolina Pradier y Laia Domenech Burin"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---


```{r setup, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE, tidy=TRUE)
```


```{r librerias}
library(tidyverse)
library(eph)
library(spatstat)
options(dplyr.summarise.inform = FALSE)
```

# Introducción

# Visualización interactiva

La visualización interactiva va a permitir que los usuarios de nuestras visualizaciones puedan explorar nuestros resultados con mayor libertad. Es decir, van a permitir que cada usuario pueda analizar con mayor detalle lo que más le interesa.

Vamos a volver a trabajar con la base de EPH para encontrar la brecha salarial entre varones y mujeres para cada sector productivo, y luego vamos a graficarlo interactivamente.

```{r}
base <- eph::get_microdata(year = 2019, 
                            trimester = 1,
                            type = "individual", 
                            destfile = "bases_fuentes/eph_2019_T1.rds")  %>% 
  organize_caes()%>%  #recodifica la variable que indica el sector de la ocupación
  select(ESTADO,"SEXO" = CH04, "Ing_Ocup_Principal"= P21, PONDIIO,caes_eph_label, "Horas" = PP3E_TOT) %>% 
  
  mutate(ESTADO = case_when(ESTADO == 1 ~ "Ocupado",
                            ESTADO == 2 ~ "Desocupado",
                            ESTADO == 3 ~ "Inactivo",
                            ESTADO == 4 ~ "Menor de 10 años"),
         SEXO = case_when(SEXO == 1 ~ "Varones",
                          SEXO == 2 ~ "Mujeres")) %>% 
  filter(Ing_Ocup_Principal != -9) %>%  #valor de no respuesta
  filter(ESTADO == "Ocupado")



```


Calculamos el ingreso medio de los trabajadores de cada sexo y sector, y luego la brecha. También vamos a tener en cuenta en qué sectores las mujeres tienen una participación mayor.

```{r}

#Aclaración: el ponderador para la variable de ingreso de la ocupación proncipal es PONDIIO

ingresos <- base %>% 
  filter(Ing_Ocup_Principal > 0) %>%
  group_by(SEXO,caes_eph_label) %>% 
  summarise(Ingreso_medio = weighted.mean(Ing_Ocup_Principal,PONDIIO, na.rm = T)) %>% 
  pivot_wider(id_cols = caes_eph_label, names_from = SEXO, values_from = Ingreso_medio) %>% 
  mutate(Brecha =  ((Varones-Mujeres)/Varones))

participacion <-  base %>% 
  group_by(SEXO,caes_eph_label) %>%
  summarise(Casos = n()) %>% 
  ungroup() %>% 
  group_by(caes_eph_label) %>% 
  mutate(Total = sum(Casos),
         Prop = (Casos/Total)*100) %>% 
  filter(SEXO == "Mujeres") %>% 
  select(caes_eph_label, Prop)

ingresos <- ingresos %>% 
  left_join(.,participacion, by = "caes_eph_label")

ingresos

```



## plotly

Para graficar nuestros resultados, vamos a recurrir al paquete *plotly*. Este paquete nos ayuda a crear gráficos interactivos (y puede utilizarse en combinación con ggplot para transformar un gráfico no interactivo en un gráfico interactivo).

```{r}
library(plotly)
```


En nuestro gráfico, vamos a graficar el ingreso medio de cada sector productivo para trabajadores de cada sexo, coloreando cada burbuja de acuerdo con la magnitud de la brecha, y determinando el tamaño de la burbuja según la proporción de trabajadoras mujeres en el sector.

```{r}
plot_ly(ingresos, x = ~Mujeres, y = ~Varones, 
        color = ~Brecha, colors = 'Spectral',
        type = 'scatter', mode = 'markers',  marker = list(size = ~Prop, opacity = 0.9),
        
        hoverinfo = 'text',
        text = ~paste(caes_eph_label, '<br>Mujeres:', paste0("$",round(Mujeres,1)), '<br>Varones:', paste0("$",round(Varones,1)), '<br>Brecha:', paste0(round(Brecha*100,1), "%"), '<br>Proporción de trabajadoras mujeres:', paste0(round(Prop,1), "%"))
        
        ) %>% 
       layout(title = 'Ingreso medio y brecha salarial por sector productivo',
         xaxis = list(showgrid = FALSE),
         yaxis = list(showgrid = FALSE))
```
Prueben pasar el mouse por encima del gráfico, moverlo, hacer zoom, etc. 

¿Qué análisis podemos hacer de la información representada? 


### Bonus

Más ideas: https://plotly.com/r/

Para seguir avanzando: 

* https://jkunst.com/highcharter/

* http://rstudio.github.io/dygraphs/


# Iteración y funciones

La iteración y las funciones nos van a permitir reducir la duplicación en el código (copiar y pegar las mismas instrucciones). 

¿Por qué reducir la duplicación?

* Es más fácil entender tu código (para vos en otro momento, o para un tercero). 

* Es más simple realizar cambios y encontrar errores. 

Además, van a potenciar nuestro trabajo con R, permitiéndonos escalar la cantidad de procesamientos y visualizaciones que podemos obtener a partir del análisis de una base de datos en muy poco tiempo.

## Iteraciones

La iteración es una herramienta para repetir la misma tarea con múltiples inputs (variables, conjuntos de datos, etc.).

Un loop es una estructura de código que nos permite aplicar iterativamente un mismo conjunto de comandos, variando el valor de una variable. Su estructura general es la siguiente:

```{r}
for (variable in vector) {
  #Operaciones
}
```

El nombre que definamos para la variable debe ser el mismo que utilicemos para realizar las operaciones dentro del loop, pero puede ser cualquiera (x,i,planta,supercalifragil, etc).

Por ejemplo:

```{r}
for (x in 1:5) {
  print(x*x)
}

```
Lo que hizo el código fue crear una variable x, que fue tomando los valores 1, 2, 3, 4 y 5, y en cada caso multiplicándose por sí misma.

En nuestro loop pueden intervenir también objetos que hayamos definido previamente. 

Por ejemplo:

```{r}

b <- 10

for (x in 1:5) {
  print(x+b)
}

```
Una herramienta que vamos a utilizar mucho es la función *seq()*, que permite generar una secuencia de números (que vamos a utilizar para iterar). Por default, si ingresamos un único número como argumento, genera una secuencia desde 1 hasta ese número.

```{r}

seq(3)

for (i in (seq(3))) {
  print(i)
}


```
¿Cuándo podríamos usar esto? En operaciones de *subsetting* o *slicing*

```{r}

#defino el vector
vec <- c("a","b","c")

#¿cuántos elementos tiene?
length(vec)

#Convierto cada elemento al mismo elemento en mayúscula
for (letra in (seq(length(vec)))) {
  vec[letra] <- toupper(vec[letra])
}

#¿Cómo quedó?
vec

```
¿Qué pasó? Nuestro loop fue avanzando sobre los elementos de vec, reemplazándolos por el mismo valor en mayúscula. Por ejemplo, al vec[1] = "a", lo transformó en "A".

### Aplicación sobre una base de datos

Veamos cómo puede ser útil para un procesamiento. 

Si tenemos una base de datos con información sobre distintos tipos de población, podemos querer generar una medida resumen para cada segmento de la población.

Por ejemplo, supongamos que queremos llevar a cabo un análisis más detallado de la distribución de los ingresos por sexo para cada rama de actividad:


```{r}

vector_valores <- unique(base$caes_eph_label)

#En esta lista vamos a guardar nuestros resultados
resultados <- list()

for (valor in (seq(length(vector_valores)))) {
  
  tabla_resumen <- base %>% 
    filter(caes_eph_label == vector_valores[valor]) %>% 
    filter(Ing_Ocup_Principal > 0) %>% 
    group_by(SEXO) %>% 
    summarise(sector = unique(caes_eph_label),
              max_ing = max(Ing_Ocup_Principal, na.rm = T),
              min_ing = min(Ing_Ocup_Principal, na.rm = T),
              media_ing = weighted.mean(Ing_Ocup_Principal, PONDIIO, na.rm = T),
              mediana_ing = weighted.median(Ing_Ocup_Principal, PONDIIO, na.rm = T))
  
  resultados[[valor]] <-  tabla_resumen
  
}

#Veamos una de las tablas que generamos:

resultados[[3]]

```

También podemos presentar nuestros resultados de una manera más amigable con quien está leyendo, o listo para copiar e incluir en un informe:

```{r}

for (valor in (seq(length(vector_valores)))) {
  
  print(paste0("Para el sector ", unique(resultados[[valor]]$sector), ", el ingreso máximo alcanzado por un varón fue de $", resultados[[valor]]$max_ing[resultados[[valor]]$SEXO == "Varones"], ". Para las mujeres, por otro lado, fue de $", resultados[[valor]]$max_ing[resultados[[valor]]$SEXO == "Mujeres"]))
  
  
}

```


## Funciones

Retomamos lo introducido en la clase 2: la función es una forma de encapsular una serie de operaciones a las que vayamos a recurrir más de una vez, esta es su estructura general: 

```{r}
fun_ej <-function(argumentos){
	#[se hace algún cómputo]
}
```

En este caso, vamos a utilizar esta herramienta -en conjunto con la iteración- para generar una serie de gráficos donde se visualice la distribución de los ingresos de las mujeres y los varones que se desempeñan en cada sector productivo en la base de datos.

Primero, vamos a generar los datos que vamos a graficar: 

```{r}
vector_valores <- unique(base$caes_eph_label)

#En esta lista vamos a guardar nuestros resultados
datos_graf <- list()

for (valor in (seq(length(vector_valores)))) {
  
  tabla_resumen <- base %>% 
    filter(caes_eph_label == vector_valores[valor]) %>% 
    filter(Ing_Ocup_Principal > 0) %>% 
     filter(Horas > 0) %>% 
    group_by(SEXO, Ing_Ocup_Principal, Horas) %>% 
    summarise(Casos = sum(PONDIIO, na.rm = T),
              sector = unique(caes_eph_label)) 
  
  datos_graf[[valor]] <-  tabla_resumen
  
}


```


```{r}

ggplot(datos_graf[[1]], aes(x = Horas, y = Ing_Ocup_Principal, size =Casos, color = SEXO)) +
        geom_point(alpha = 0.5)+
        theme_minimal()+
        labs(title = unique(datos_graf[[1]]$sector),
             y = "Ingreso de la ocupación principal",
             x = "Horas semanales trabajadas",
             color = "Sexo")

```


Luego, creamos nuestra función:

```{r}

crear_grafico = function(tabla){
  
  +ggsave(paste0("clase6/graficos/",xx,".png"))
  
}

```

Luego, la aplicamos de forma iterativa:

```{r}

for (i in seq(length(datos_graf))) {
  
  crear_grafico(datos_graf[[i]])
  
}

```

Los resultados de nuestro prcesamiento están guardados en la carpeta graficos de la clase 6.


# Algunos ejercicios para empezar a practicar