---
title: "Clase 6 - Visualización de gráficos e iteraciones"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
author: "Carolina Pradier y Laia Domenech Burin"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---


```{r setup, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE, tidy=FALSE)
```


```{r librerias}
library(tidyverse)
library(eph)
library(spatstat)
options(scipen = 9999) #la opción scipen modifica el límite en el que los números decimales pasan a expresarse con notación científica. En este caso, lo utilizamos para evitar la notación científica.
options(dplyr.summarise.inform = FALSE)

```

# Introducción

En la clase de hoy vamos a explorar nuevas formas de procesar una base de datos y visualizar nuestros resultados.

En particular, vamos a introducir el paquete *plotly* para generar visualizaciones interactivas.

Por último, vamos a trabajar con *funciones* e *iteraciones* para escalar nuestra capacidad de análisis de datos y presentación de resultados.

# Visualización interactiva

La visualización interactiva va a permitir que los usuarios de nuestras visualizaciones puedan explorar nuestros resultados con mayor libertad. Es decir, van a permitir que cada usuario pueda analizar con mayor detalle lo que más le interesa.

Vamos a volver a trabajar con la base de EPH para encontrar la brecha salarial entre varones y mujeres para cada sector productivo, y luego vamos a graficarlo interactivamente.

```{r}
base <- eph::get_microdata(year = 2019, 
                            trimester = 1,
                            type = "individual", 
                            destfile = "clase6/eph_2019_T1.rds")  %>% 
  organize_caes()%>%  #recodifica la variable que indica el sector de la ocupación
  select(ESTADO,"SEXO" = CH04, "Ing_Ocup_Principal"= P21, PONDIIO,caes_eph_label, "Horas" = PP3E_TOT, PONDERA) %>% 
  
  mutate(ESTADO = case_when(ESTADO == 1 ~ "Ocupado",
                            ESTADO == 2 ~ "Desocupado",
                            ESTADO == 3 ~ "Inactivo",
                            ESTADO == 4 ~ "Menor de 10 años"),
         SEXO = case_when(SEXO == 1 ~ "Varones",
                          SEXO == 2 ~ "Mujeres")) %>% 
  filter(Ing_Ocup_Principal != -9) %>%  #excluimos el valor de no respuesta
  filter(ESTADO == "Ocupado")

```


Calculamos el ingreso medio de los trabajadores de cada sexo y sector, y luego la brecha. También vamos a tener en cuenta en qué sectores las mujeres tienen una participación mayor.

```{r}

#Aclaración: el ponderador para la variable de ingreso de la ocupación proncipal es PONDIIO

ingresos <- base %>% 
  filter(Ing_Ocup_Principal > 0) %>% #excluimos a personas con ingreso = 0
  group_by(SEXO,caes_eph_label) %>% 
  summarise(Ingreso_medio = weighted.mean(Ing_Ocup_Principal,PONDIIO, na.rm = T)) %>% #al igual que en otras funciones, en este caso na.rm excluye los valores faltantes del promedio ponderado
  pivot_wider(id_cols = caes_eph_label, names_from = SEXO, values_from = Ingreso_medio) %>% 
  mutate(brecha =  ((Varones-Mujeres)/Varones))

ingresos

```

```{r}
feminizacion <-  base %>% 
  group_by(SEXO,caes_eph_label) %>%
  summarise(Casos = sum(PONDERA)) %>% 
  ungroup() %>% 
  group_by(caes_eph_label) %>% 
  mutate(Total = sum(Casos),
         feminizacion = (Casos/Total)*100) %>% 
  filter(SEXO == "Mujeres") %>% 
  select(caes_eph_label, feminizacion)

feminizacion

```

```{r}
ingresos <- ingresos %>% 
  left_join(.,feminizacion, by = "caes_eph_label")

ingresos
```

Tal como se refleja en nuestros resultados, las brechas de ingresos tienden a estar a favor de los varones. No obstante, es interesante vincular este análisis con la tasa de feminización para interpretar casos como el del sector de la Construcción, donde la mayor parte de los trabajadores son varones, pero las mujeres participan en roles que requieren una mayor calificación (trabajo de oficina, arquitectas, etc.): esto tiene como resultado una brecha de ingresos a favor de las mujeres.

## plotly

Para graficar nuestros resultados, vamos a recurrir al paquete *plotly*. Este paquete nos ayuda a crear gráficos interactivos (y puede utilizarse en combinación con ggplot para transformar un gráfico no interactivo en un gráfico interactivo).

```{r}
library(plotly)
```


En nuestro gráfico, vamos a graficar el ingreso medio de cada sector productivo para trabajadores de cada sexo, coloreando cada burbuja de acuerdo con la magnitud de la brecha, y determinando el tamaño de la burbuja según la proporción de trabajadoras mujeres en el sector.

```{r}

#La sintaxis es un poco distinta a la de ggplot, más abajo podemos ver cómo recurrir a ella si nos resulto más cómoda

plot_ly(ingresos, x = ~Mujeres, y = ~Varones, 
        color = ~brecha, colors = 'Spectral',
        type = 'scatter', mode = 'markers',  marker = list(size = ~feminizacion, opacity = 0.9),
        
        hoverinfo = 'text',
        text = ~paste(caes_eph_label, '<br>Mujeres:', paste0("$",round(Mujeres,1)), '<br>Varones:', paste0("$",round(Varones,1)), '<br>Brecha:', paste0(round(brecha*100,1), "%"), '<br>Proporción de trabajadoras mujeres:', paste0(round(feminizacion,1), "%"))
        
        ) %>% 
       layout(title = 'Ingreso medio y brecha salarial por sector productivo',
         xaxis = list(showgrid = FALSE),
         yaxis = list(showgrid = FALSE),
         font = list(family ="Times New Roman"))
```
Prueben pasar el mouse por encima del gráfico, moverlo, hacer zoom, etc. 

¿Qué análisis podemos hacer de la información representada? 


## ggplotly()

La función **ggplotly()** convierte nuestros ggplots en plotly. De esta forma, podemos tomar cualquiera de las visualizaciones que aprendimos a hacer la clase pasada y *hacerla interactiva*. 

Por ejemplo:

```{r}

feminizacion <-  base %>% 
  group_by(SEXO,caes_eph_label) %>%
  summarise(Casos = sum(PONDERA)) %>% 
  ungroup() %>% 
  group_by(caes_eph_label) %>% 
  mutate(Total = sum(Casos),
         feminizacion = (Casos/Total)*100)%>% 
  filter(SEXO == "Mujeres") %>% 
  select(caes_eph_label, feminizacion)


feminizacion

```


```{r}
#paleta de colores divina!
library(wesanderson)


plot_estatico <- feminizacion %>% 
  ggplot(.,aes(x = fct_reorder(caes_eph_label,feminizacion), y = feminizacion, 
        fill = feminizacion,
        #para que el hovertext nos quede como queremos en el siguiente paso 
        text = paste(caes_eph_label, '<br>Proporción de trabajadoras mujeres:', paste0(round(feminizacion,1), "%"))
  )
        )+
  geom_col(alpha = 0.9)+
  theme_minimal()+
  coord_flip()+
  labs(title = 'Tasa de feminización de las ramas de actividad',
       x="",y="")+
  scale_y_continuous(labels = function(x) paste0(x,"%"))+
  scale_x_discrete(labels = function(x) str_wrap(x,25))+
  scale_fill_gradientn(colours = wes_palette("Zissou1", 100, type = "continuous")) +
  guides(fill = "none")


plot_estatico


```

```{r}
#lo hacemos interactivo

ggplotly(plot_estatico, 
         tooltip = "text") %>% 
  layout(font = list(family ="Times New Roman"))
```



### Bonus

Más ideas: https://plotly.com/r/

Para seguir avanzando: 

* https://jkunst.com/highcharter/

* http://rstudio.github.io/dygraphs/


# Iteración y funciones

La iteración y las funciones nos van a permitir reducir la duplicación en el código (copiar y pegar las mismas instrucciones). 

¿Por qué reducir la duplicación?

* Es más fácil entender tu código (para vos en otro momento, o para un tercero). 

* Es más simple realizar cambios y encontrar errores. 

Además, van a potenciar nuestro trabajo con R, permitiéndonos escalar la cantidad de procesamientos y visualizaciones que podemos obtener a partir del análisis de una base de datos en muy poco tiempo.

## Iteraciones

La iteración es una herramienta para repetir la misma tarea con múltiples inputs (variables, conjuntos de datos, etc.).

Un loop es una estructura de código que nos permite aplicar iterativamente un mismo conjunto de comandos, variando el valor de una variable. Su estructura general es la siguiente:

```{r, eval=F}
for (variable in vector) {
  #Operaciones
}
```

El nombre que definamos para la variable debe ser el mismo que utilicemos para realizar las operaciones dentro del loop, pero puede ser cualquiera (x,i,planta,supercalifragil, etc).

Por ejemplo:

```{r}
for (x in 1:5) {
  print(x*x)
}

```
Lo que hizo el código fue crear una variable x, que fue tomando los valores 1, 2, 3, 4 y 5, y en cada caso multiplicándose por sí misma.

En nuestro loop pueden intervenir también objetos que hayamos definido previamente. 

Por ejemplo:

```{r}

b <- 10

for (x in 1:5) {
  print(x+b)
}

```
Una herramienta que vamos a utilizar mucho es la función *seq()*, que permite generar una secuencia de números (que vamos a utilizar para iterar). Por default, si ingresamos un único número como argumento, genera una secuencia desde 1 hasta ese número.

```{r}

seq(3)

for (i in (seq(3))) {
  print(i)
}


```
¿Cuándo podríamos usar esto? En operaciones de *subsetting* o *slicing*

```{r}

#defino el vector
vec <- c("a","b","c")

#¿cuántos elementos tiene?
length(vec)

#Convierto cada elemento al mismo elemento en mayúscula
for (letra in (seq(length(vec)))) {
  vec[letra] <- toupper(vec[letra])
}

#¿Cómo quedó?
vec

```
¿Qué pasó? Nuestro loop fue avanzando sobre los elementos de vec, reemplazándolos por el mismo valor en mayúscula. Por ejemplo, al vec[1] = "a", lo transformó en "A".

### Aplicación sobre una base de datos

Veamos cómo puede ser útil para un procesamiento. 

Si tenemos una base de datos con información sobre distintos tipos de población, podemos querer generar una medida resumen para cada segmento de la población.

Por ejemplo, supongamos que queremos llevar a cabo un análisis más detallado de la distribución de los ingresos por sexo para cada rama de actividad:


```{r}

vector_valores <- unique(base$caes_eph_label)

#En esta lista vamos a guardar nuestros resultados
resultados <- list()

for (valor in (seq(length(vector_valores)))) {
  
  tabla_resumen <- base %>% 
    filter(caes_eph_label == vector_valores[valor]) %>% 
    filter(Ing_Ocup_Principal > 0) %>% 
    group_by(SEXO) %>% 
    summarise(sector = unique(caes_eph_label),
              max_ing = max(Ing_Ocup_Principal, na.rm = T),
              min_ing = min(Ing_Ocup_Principal, na.rm = T),
              media_ing = weighted.mean(Ing_Ocup_Principal, PONDIIO, na.rm = T),
              mediana_ing = weighted.median(Ing_Ocup_Principal, PONDIIO, na.rm = T))
  
  resultados[[valor]] <-  tabla_resumen
  
  #En este caso, estamos usando “valor” como iterador, en el sentido de índice dentro de un vector (vector_valores). Si en cada iteración, además de nuestro procesamiento imprimos "valor", obtenemos la serie de índices.
  
  print(valor)
  
  #Es decir, no estamos recurriendo directamente a cada uno de los valores del vector, sino que cada sector se corresponde con uno de estos índices. Los podemos obtener (por ejemplo) así:
  
  print(unique(as.character(tabla_resumen$sector)))
  
  #Al iterar, print puede ser muy útil para entender qué está pasando (especialmente si los resultados no son los que esperamos!).
  
}


```

```{r}
#Veamos una de las tablas que generamos:

resultados[[3]]
```


También podemos presentar nuestros resultados de una manera más amigable con quien está leyendo, o listo para copiar e incluir en un informe:

```{r}

for (valor in (seq(length(vector_valores)))) {
  
  print(paste0("Para el sector ", unique(resultados[[valor]]$sector), ", el ingreso máximo alcanzado por un varón fue de $", resultados[[valor]]$max_ing[resultados[[valor]]$SEXO == "Varones"], ". Para las mujeres, por otro lado, fue de $", resultados[[valor]]$max_ing[resultados[[valor]]$SEXO == "Mujeres"]))
  
  
}

```


## Funciones

Retomamos lo introducido en la clase 2: la función es una forma de encapsular una serie de operaciones a las que vayamos a recurrir más de una vez, esta es su estructura general: 

```{r}
fun_ej <-function(argumentos){
	#[se hace algún cómputo]
}
```

En este caso, vamos a utilizar esta herramienta -en conjunto con la iteración- para generar una serie de gráficos donde se visualice la distribución de los ingresos de las mujeres y los varones que se desempeñan en cada sector productivo de acuerdo con las horas que trabajan por semana.

Primero, vamos a generar los datos que vamos a graficar: 

```{r}
vector_valores <- unique(base$caes_eph_label)

#En esta lista vamos a guardar nuestros resultados
datos_graf <- list()

for (valor in (seq(length(vector_valores)))) {
  
  tabla_resumen <- base %>% 
    filter(caes_eph_label == vector_valores[valor]) %>% 
    filter(Ing_Ocup_Principal > 0) %>% 
     filter(Horas > 0) %>% 
    filter(Horas != 999) %>% 
    group_by(SEXO, Ing_Ocup_Principal, Horas) %>% 
    summarise(Casos = sum(PONDIIO, na.rm = T),
              sector = unique(caes_eph_label)) 
  
  datos_graf[[valor]] <-  tabla_resumen
  
}


```


Veamos cómo queda algún elemento:

```{r}

datos_graf[[2]]

```



Luego, creamos nuestra función que grafica la información de una tabla:

```{r}

crear_grafico = function(tabla){
  
  ggplot(tabla, aes(x = Horas, y = Ing_Ocup_Principal, size =Casos, color = SEXO)) +
        geom_point(alpha = 0.4)+
        theme_minimal()+
        scale_color_manual(values = c("deeppink4","mediumseagreen"))+
         scale_size_continuous(range = c(2, 15))+
        scale_y_continuous(labels = function(x) paste0("$",x))+
        facet_wrap(~SEXO, scales = "fixed", nrow = 1)+
        labs(title = unique(tabla$sector),
             y = "Ingreso de la ocupación principal",
             x = "Horas semanales trabajadas",
             color = "Sexo")+
        theme(legend.position = "bottom")+
    ggsave(paste0("clase6/graficos/",tolower(str_replace_all(unique(tabla$sector), " ", "_")),".png"))
  
}


```

Finalmente, la aplicamos de forma iterativa:

```{r, eval=F}

for (i in seq(length(datos_graf))) {
  
  crear_grafico(datos_graf[[i]])
  
}

```

Los resultados de nuestro procesamiento están guardados en la carpeta graficos de la clase 6.


¡Terminamos! Ahora, vamos a la parte práctica. 