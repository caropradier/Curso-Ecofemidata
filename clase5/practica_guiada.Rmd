---
title: "Clase 5 - Visualización de datos"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
author: "Carolina Pradier y Laia Domenech Burin"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r setup, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE, tidy=TRUE)
```

## Mirando datos

Cuando estamos haciendo un gráfico, hacemos que nuestros datos sean comprensibles visualmente de manera rápida. La visualización de datos es un trabajo esencial, y en general nos puede dar respuestas simples a las preguntas de nuestros problemas de investigación. 

En esta clase vamos a ver una aproximación a los principios básicos de la visualización de datos y cómo plasmarlos en la librería `ggplot`. Este está incluído en la librería `tidyverse`, por lo que no hace falta que lo vuelvan a descargar. 

Hay dos cuestiones centrales de `ggplot` para saber: 

- Incluye funciones para realizar una gran variedad de visualizaciones. 
- Su concepto central es la asignación (*mapping* en inglés) de atributos estéticos a los valores que toma una variable. Dicho de otra forma, permite mostrar de modo perceptible a la vista la diferencia entre valores: con distintos colores, distintos tamaños, distintas posiciones en un gráfico, etc.

## Visualización con `ggplot`

Vamos a ello. En primer lugar, vamos a hacer lo que ya sabemos. Importamos la librería `tidyverse`, que va a contener el paquete y la base de datos del primer trimestre de 2019 de la EPH.

```{r, echo=TRUE, warning=TRUE}
library(tidyverse)

base <- eph::get_microdata(year = 2019, #definimos el año
                            trimester = 1, #definimos el trimestre
                            type = "individual", 
                            destfile = "./data/eph_2019_T1.rds") %>%  
  select(REGION, CH06, ESTADO, CAT_OCUP , "SEXO" = CH04, PP08D1) %>% 
  mutate(ESTADO = case_when(ESTADO == 1 ~ "Ocupado",
                            ESTADO == 2 ~ "Desocupado",
                            ESTADO == 3 ~ "Inactivo",
                            ESTADO == 4 ~ "Menor de 10 años"),
         SEXO = case_when(SEXO == 1 ~ "Varones",
                          SEXO == 2 ~ "Mujeres"),
         CAT_OCUP = case_when(CAT_OCUP == 1 ~ "Patrón",
                            CAT_OCUP == 2 ~ "Cuenta propia",
                            CAT_OCUP == 3 ~ "Empleado",
                            CAT_OCUP == 4 ~ "TFSR"),
         REGION = case_when(
           REGION == 01 ~ "Gran Buenos Aires",
           REGION == 40 ~ "NOA",
           REGION == 41 ~ "NEA",
           REGION == 42 ~ "Cuyo",
           REGION == 43 ~ "Pampeana",
           REGION == 44 ~ "Patagonia"))

```

La unidad básica de este paquete, que llamaremos todas las veces que queramos hacer un gráfico, es la función `ggplot()`. Veamos qué sucede si la usamos:

```{r}
ggplot()
```

No se ve nada: nos aparece como un lienzo en blanco. Esto es porque la creación de visualizaciones `ggplot` sigue un marco teórico: ["la gramática de los gráficos"](https://www.slideshare.net/0xdata/leland-wilkinson-h2oai-the-grammar-of-graphics-and-the-future-of-big-data-visualization-h2o-world-2019-nyc). A grandes rasgos, podemos decir que esta gramática requiere que definamos como mínimo dos cosas: 

- una **geometría**: este es el recurso visual con el que vamos a mostrar la información. Pueden ser líneas (`geom_line()`), puntos (`geom_point()`), barras (`geom_bar()`), u otros.

- una **asignación estética** (`aes`): tenemos que indicar las variables que queremos mostrar, y que atributo estético va a representar sus valores. Podemos representar visualmente las variables a través de distintos canales: puede ser a través del color, el tamaño, la transparencia, etc. 

![Diagrama de David Keyes](./img/ggplot_resumen.png)

Vamos a intentarlo. Asignémosle al atributo `x` la variable `SEXO`  y usemos `geom_bar` para mostrar los datos.

```{r}
ggplot(base, aes(x=SEXO))+
        geom_bar()
```

La geometría `geom_bar` automáticamente hace un conteo de frecuencias de la variable que le pasemos en el eje x. De esta manera, en el eje y está el n de apariciones. Sin embargo, esto no nos va a servir si queremos mostrar proporciones por grupo. En estos casos, nos va a convenir combinar `ggplot` con un `group_by`. 

## Combinación con gramática tidy

Al estar incluida en el mundo `tidyverse`, podemos combinar ggplot con otros objetos a través de `%>%`. Esto es útil sobre todo en combinación con la función `group_by()` para realizar conteos de frecuencias, sumas de columnas, y otras operaciones. Probemos agrupando el precio medio de productos por región y haciendo un gráfico que pone `Region` en el eje `x`, el `precio` en el eje `y` y usa la geometría `geom_bar()`. Como en este caso no queremos mostrar un conteo sino diferencias entre valores y asignamos el eje y nosotros, le pasamos el atributo `stat = 'identity'`. `ggplot` [tiene un amplio repertorio de geometrías](https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-visualization-2.1.pdf).

```{r}
base %>% group_by(REGION)%>%
        summarise(edad_media = mean(CH06)) %>%
        ggplot(aes(x=REGION, y=edad_media))+
        geom_bar(stat = 'identity')

```

Esto también nos es útil si queremos filtrar casos antes de hacer el gráfico. Por ejemplo, hagamos un gráfico de cómo evoluciona la mediana de ingresos de las personas asalariadas según edad. 

```{r}
base %>% 
  filter(CAT_OCUP == "Empleado")%>% #Filtramos a las personas asalariadas
  group_by(CH06)%>% #Agrupamos por edad 
  summarise(ingreso_mediana=median(PP08D1, na.rm = TRUE)) %>% #Calculamos la mediana de ingresos
  ggplot(aes(x=CH06, y=ingreso_mediana))+ #Pasamos al eje x la edad y al eje y la mediana de ingresos
  geom_line() #Aplicamos una geometría de líneas

```

Se puede elegir entre una variada colección de geoms para hacer toda clase de gráficos. Por ejemplo, `geom_boxplot()` crea _boxplots_ (o ["diagramas de caja"](https://economipedia.com/definiciones/diagrama-de-caja.html)). Al hacer boxplots es común mostrar un gráfico separado para cada categoría presente en la data a mostrar, usando para eso el eje de las `x` o de las `y`. ¡Hagamos eso mismo! Pongamos `PP08D1` en el eje `y`, `REGION` en el eje de las `x`, y a dibujar cajas con `geom_boxplot()`.

```{r}
base %>% 
  filter(CAT_OCUP == "Empleado")%>% 
  ggplot(aes(x = REGION, y = PP08D1)) +
  geom_boxplot()
```


## Agregándole color

Podemos mostrar más variables agregando colores a los gráficos. Probemos mostrar cómo varía el estado ocupacional de las personas según género en un gráfico. En esta ocasión vamos a usar la geometría `geom_col()`, que es otra forma de hacer gráficos de barras.

```{r}
base %>% 
  filter(ESTADO != "Menor de 10 años")%>% #Filtramos a los menores 
  group_by(SEXO, ESTADO) %>% #Agrupamos por sexo y estado
  summarise(n=n())%>% #Contamos
  ggplot(aes(x=SEXO, y=n, fill = ESTADO))+ #Le pasamos al eje x el sexo, al eje y la cantidad de casos y al atributo fill el estado ocupacional
  geom_col()
```

Con `fill` hicimos que el relleno de las barras se pinte según el estado ocupacional de las personas. Podemos apreciar que existe una segmentación de género en la inserción en el mercado laboral. Sin embargo, podríamos apreciar mejor estas diferencias viendo las barras de relleno una al lado de la otra. Esto lo podemos modificar asignándole el parámetro `"dodge"` al atributo `position` dentro de `geom_col`.  

```{r}
base %>% 
  filter(ESTADO != "Menor de 10 años")%>% #Filtramos a los menores 
  group_by(SEXO, ESTADO) %>% #Agrupamos por sexo y estado
  summarise(n=n())%>% #Contamos
  ggplot(aes(x=SEXO, y=n, fill = ESTADO))+ #Le pasamos al eje x el sexo, al eje y la cantidad de casos y al atributo fill el estado ocupacional
  geom_col(position = "dodge")
```

Y, si tuviésemos una distribución desigual de varones y mujeres podría ser útil mostrar estas diferencias en una única barra de proporciones. Esto lo logramos pasándole el valor `"fill"` a `position`.

```{r}
base %>% 
  filter(ESTADO != "Menor de 10 años")%>% #Filtramos a los menores 
  group_by(SEXO, ESTADO) %>% #Agrupamos por sexo y estado
  summarise(n=n())%>% #Contamos
  ggplot(aes(x=SEXO, y=n, fill = ESTADO))+ #Le pasamos al eje x el sexo, al eje y la cantidad de casos y al atributo fill el estado ocupacional
  geom_col(position = "fill")

```

Ahora, vamos a escapar un poco de las barras. Podemos replicar el gráfico de evolución de ingresos a lo largo de los años pero introduciendo la variable de género. 

Esto lo podemos hacer en un gráfico de densidad. Lo que muestran es la distribución de probabilidad de la variable, es decir que tan probable es encontrar un valor determinado si tomaramos al azar una de las observaciones. Para esto, tenemos que pasarle al atributo `x` la variable de interés y agregar la geometría `geom_density()`. Probémoslo.

```{r}

base %>% 
  filter(CAT_OCUP == "Empleado")%>% #Filtramos a las personas asalariadas
  ggplot(aes(x=PP08D1, fill = SEXO))+ #Pasamos al eje x la edad y al eje y la mediana de ingresos
  geom_density() #Aplicamos una geometría de densidad

```

Para revelar cualquier “sorpresa” que pudiera haber quedado oculta en las distribuciones tapadas por otras, ajustamos el atributo de `alpha`, que por cierto puede usarse con cualquier geometría de ggplot para controlar su grado de transparencia. Intentemos asignando una transparencia del 50% con `alpha = 0.5`:

```{r}
base %>% 
  filter(CAT_OCUP == "Empleado")%>% #Filtramos a las personas asalariadas
  ggplot(aes(x=PP08D1, fill = SEXO))+ #Pasamos al eje x la edad y al eje y la mediana de ingresos
  geom_density(alpha = 0.5) #Aplicamos una geometría de densidad
```
`ggplot` automáticamente asigna una paleta de colores predeterminada. Sin embargo, podemos instalar paquetes que introducen una gama de paletas nuevas, generalmente mejores que las que tiene R. Por ejemplo `viridis` trae paletas que, además de ser lindas, están diseñadas para poder imprimirse en escala de grises y ser interpretadas por personas con daltonismo. Probemos usar una paleta de este paquete en nuestro gráfico de arriba. Primero vamos a importar la librería `viridis`, y vamos a agregarle al código anterior la capa `scale_fill_viridis_d`.

```{r}
library(viridis)

base %>% 
  filter(CAT_OCUP == "Empleado")%>% #Filtramos a las personas asalariadas
  ggplot(aes(x=PP08D1, fill = SEXO))+ #Pasamos al eje x la edad y al eje y la mediana de ingresos
  geom_density(alpha = 0.5)+ #Aplicamos una geometría de densidad
  scale_fill_viridis_d()

```

Otra cosa que podemos hacer es asignar los colores manualmente. R viene con [varios colores que podemos llamar por su nombre en inglés](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf), pero si queremos colores que no están disponibles en esta paleta podemos usar hex codes. Vamos a probarlo replicando el gráfico de barras de las variables `SEXO` y `ESTADO`.

```{r}
colores <- c("Ocupado" = '#e5616e', "Inactivo" = '#494949', "Desocupado" = "#8cddd3") #Definimos la paleta de colores de EcoFemiData asignando a cada valor un color

base %>% 
  filter(ESTADO != "Menor de 10 años")%>% #Filtramos a los menores 
  group_by(SEXO, ESTADO) %>% #Agrupamos por sexo y estado
  summarise(n=n())%>% #Contamos
  ggplot(aes(x=SEXO, y=n, fill = ESTADO))+
  geom_col(position = "fill")+
  scale_fill_manual(values = colores)

```

