---
title: "Clase 4 - Tidyverse"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
author: "Carolina Pradier y Laia Domenech Burin"
date: "`r format(Sys.time(), '%d %B, %Y')`"
---


```{r setup, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE}
knitr::opts_chunk$set(echo=TRUE, message=FALSE, warning=FALSE, tidy=FALSE)
```


```{r librerias}
library(tidyverse)
library(eph)
library(openxlsx)
options(dplyr.summarise.inform = FALSE)
```

# Introducción

La clase pasada comenzamos a trabajar con algunas funciones del paquete **tidyverse**. 

En la clase de hoy vamos a avanzar sobre nuevas funciones para explorar la información en una base de datos. En particular, vamos a estar trabajando sobre la **Encuesta Permanente de Hogares** correspondiente al primer trimestre de 2019.

En particular, vamos a estudiar cómo usar funciones para crear medidas resumen, unir dataframes y “pivotearlos”.

Por último, vamos a introducir el paquete **lubridate** para trabajar con formatos de fecha.


## Base de datos

La **Encuesta Permanente de Hogares** (EPH) es un programa nacional de producción sistemática y permanente de indicadores sociales que lleva a cabo el Instituto Nacional de Estadística y Censos (INDEC), que permite conocer las características sociodemográficas y socioeconómicas de la población (se publican sus datos trimestralmente). Se trata de la base de datos que usamos desde Ecofemidata para elaborar el informe [La desigualdad de género se puede medir.](https://ecofeminita.com/ecofemidata "Ecofemidata")

Para descargar la base de microdatos vamos a utilizar la librería **eph**, que tiene por objecto facilitar el trabajo de aquellos usuarios y usuarias de la Encuesta Permanente de Hogares - INDEC que deseen procesar datos de la misma mediante el lenguaje de programación R. 
La función *get_microdata* descarga bases de la Encuesta Permanente de Hogares a partir de 1996.

La estructura librería::función (la usamos en el caso de *eph::get_microdata()*) es útil para indicarnos de qué librería proviene una función (por ejemplo, en caso de que dos librerías distintas tengan funciones con un mismo nombre).


```{r levanto_base} 
 
base <- eph::get_microdata(year = 2019, #definimos el año
                            trimester = 1, #definimos el trimestre
                            type = "individual", #definimos el tipo de base (el INDEC brinda la base a nivel hogar y a nivel individual)
                            destfile = "clase4/eph_2019_T1.rds")  #definimos dónde se va a guardar la base. 
#De esta forma, cada vez que utilicemos este script no tenemos que volver a descargar la base
  
```

Las variables de la EPH están codificadas, vamos a reemplazar los códigos por su significado mirando el *diseño de registro* de la base.

```{r}

base <- base %>%  
  #seleccionamos las variables que vamos a necesitar
  select(ESTADO,CAT_OCUP,"SEXO" = CH04, PONDERA) %>% 
  
  #reemplazamos los códigos por su significado
  mutate(ESTADO = case_when(ESTADO == 1 ~ "Ocupado",
                            ESTADO == 2 ~ "Desocupado",
                            ESTADO == 3 ~ "Inactivo",
                            ESTADO == 4 ~ "Menor de 10 años"),
         
         SEXO = case_when(SEXO == 1 ~ "Varones",
                          SEXO == 2 ~ "Mujeres"),
         
         CAT_OCUP = case_when(CAT_OCUP == 1 ~ "Patrón",
                            CAT_OCUP == 2 ~ "Cuenta propia",
                            CAT_OCUP == 3 ~ "Empleado",
                            CAT_OCUP == 4 ~ "TFSR"))
```


# Medidas de resumen

Para obtener información a partir del procesamiento de una base de datos, generalmente vamos a utilizar conjuntamente las funciones **group_by()** y **summarise()**:

* *group_by()* cambia la unidad de análisis del dataset a grupos de filas definidos de acuerdo con las categorías de alguna variable (por ejemplo, si agrupamos según la variable SEXO, se separará a la base de datos en dos conjuntos de filas: aquellos identificados con SEXO == "Mujeres" y aquellos identificados como SEXO == "Varones"). 
De este modo, las operaciones que apliquemos sobre la base agrupada se aplicarán separadamente sobre cada uno de estos grupos. 

* *summarise()* crea una tabla nueva donde se resume información acerca del dataframe original. 
La cantidad de filas de la nueva tabla será igual a la cantidad de grupos que hayamos definido (en caso de no agrupar, vamos a tener un único grupo, que es el conjunto de todas las filas).
La cantidad de columnas de la tabla variará según la cantidad de variables por las que agrupamos y la cantidad de medidas de resumen que queramos calcular (por ejemplo, si quisiéramos conocer la cantidad de observaciones en cada grupo, el ingreso máximo de los miembros de cada grupo, y su ingreso medio, tendríamos 3 columnas).

## ¿summarise() o mutate()?

Veamos un caso:

```{r}

unique(base$SEXO)

base %>% 
  group_by(SEXO) %>% 
  summarise(Desocupados = sum(PONDERA[ESTADO == "Desocupado"], na.rm = TRUE),
            PEA = sum(PONDERA[ESTADO == "Desocupado"| ESTADO == "Ocupado"], na.rm = TRUE),
            "Tasa de desocupación" = round( (Desocupados/PEA)*100 ,1)) 

#El parámetro na.rm de la función sum() indica que, en caso de presentarse valores faltantes, se ignoren para la suma. Si esto no se aclara, en caso de presentarse un valor faltante, la función devuelve NA.
#La función round() nos permite redondear un número a la cantidad de decimales que especifiquemos (en este caso, redondeamos el resultado de (Desocupados/PEA)*100 a 1 decimal).

```
Como la encuesta entrevista a una muestra de hogares o individuos que no son directamente la población total de la que se quiere hablar (como se hace por ejemplo en un Censo), la EPH nos dice con la variable PONDERA a cuánta gente representa cada observación, cada sujeto encuestado. Entonces, cuando queremos estimar cantidades, en lugar de simplemente contar filas, sumamos los PONDERA (de acuerdo a la condición aclarada entre corchetes)

La tabla que obtenemos tiene 2 filas (las categorías de sexo) y cuatro columnas: una en la que aparece la variable que agrupa y tres donde aparecen las medidas de resumen que nos interesaba calcular. Lo que puede observarse en la tabla es que la tasa de desocupación es mayor para las mujeres.

¿Qué pasa si en lugar de *summarise()* utilizábamos *mutate()*?

```{r}

base %>% 
  group_by(SEXO) %>% 
  mutate(Desocupados = sum(PONDERA[ESTADO == "Desocupado"], na.rm = TRUE),
          PEA = sum(PONDERA[ESTADO == "Desocupado"| ESTADO == "Ocupado"], na.rm = TRUE),
          "Tasa de desocupación" = round((Desocupados/PEA)*100,1)) 

```

Obtenemos una tabla igual a la original, pero esta vez en cada fila correspondiente a las mujeres aparece la medida de resumen que le corresponde a ese grupo, y lo mismo para las filas correspondientes a varones. Es decir, mutate() no colapsa la información según los grupos definidos, sino que mantiene la misma cantidad de filas originales e imprime para cada caso la medida de resumen correspondiente al grupo al que pertenece cada observación.

## Múltiples argumentos en group_by()

Si en el argumento de group_by() incluyéramos más de una variable, la cantidad de filas que obtendremos tras generar alguna medida de resumen sería igual a las combinaciones de valores entre las variables elegidas presentes en la tabla.

```{r}
base %>%
  filter(ESTADO=="Ocupado") %>% #Me quedo con la población ocupada
  group_by(SEXO, CAT_OCUP) %>% 
  summarise(casos = sum(PONDERA))
```

## ungroup()

Finalmente, para seguir trabajando con el objeto que está agrupado sin esos grupos, hay que usar la función **ungroup()**. Si no, por default R deja el objeto (nuestra tabla) agrupado por la primera variable que aparece como argumento de **group_by()**.

```{r}
base %>%
  filter(ESTADO=="Ocupado") %>% #Me quedo con la población ocupada
  group_by(SEXO, CAT_OCUP) %>% 
  summarise(Casos = sum(PONDERA)) %>% 
  
  #Prueba: ¿qué pasa si comentamos las siguientes 2 líneas de código?
  ungroup() %>%  
  group_by(SEXO) %>% 
  
  
  mutate(Total = sum(Casos),
         "Frecuencia relativa" = round((Casos/Total)*100,1))


```


# Pivots

En algunos casos, vamos a necesitar transformar la presentación de la información en un dataframe (ya sea para presentar nuestros resultados, o para algún procesamiento posterior -por ejemplo, generar una visualización-). A estos fines, vamos a necesitar las funciones **pivot_wider()** y **pivot_longer()**.

## pivot_wider()

*pivot_wider()* crea variables a partir de filas, y “ensancha” la base de datos. Tiene los siguientes parámetros: 

+ id_cols: la columna de ID, que no queremos que pierda su formato 

+ names_from: indico en qué columna están los nombres de las variables

+ values_from: indico en qué columna están los valores de las variables

Veamos un ejemplo:

```{r}
base %>% 
  filter(!is.na(ESTADO)) %>% 
  group_by(SEXO, ESTADO) %>% 
  summarise(Casos = sum(PONDERA)) %>% 
  pivot_wider(.,id_cols=SEXO,names_from=ESTADO,values_from = Casos)
```


## pivot_longer()

*pivot_longer()* es la operación inversa. 
“Alarga” los datos convirtiendo columnas a filas. Tiene los siguientes parámetros: 

+ cols: elijo las columnas que quiero pasar a filas 

+ names_to: indico el nombre de la columna que va a contener las variables elegidas 

+ values_to: indico el nombre de la columna que va a contener los valores de las variables

Revertimos la operación del ejemplo anterior:

```{r}
base %>% 
  filter(!is.na(ESTADO)) %>%
  group_by(SEXO, ESTADO) %>% 
  summarise(Casos = sum(PONDERA)) %>% 
  pivot_wider(.,id_cols=SEXO,names_from=ESTADO,values_from = Casos) %>% 
  pivot_longer(.,cols = c("Desocupado", "Inactivo","Menor de 10 años", "Ocupado"), names_to = "ESTADO", values_to = "Casos")
```




# Unión de bases

Para unir bases de datos a partir de un identificador común vamos a recurrir a distintas funciones join():

+ inner_join(): el resultado incluye todas las filas que estén presentes tanto en x como en y.
+ left_join(): el resultado incluye todas las filas que estén presentes en x (agregando las columnas de y con información sobre estas filas).
+ right_join(): el resultado incluye todas las filas que estén presentes en y (agregando las columnas de x con información sobre estas filas).
+ full_join(): el resultado incluye todas las filas que estén en x o y.
+ anti_join(): el resultado incluye todas las filas de x que no estén presentes en y (sólo muestra las columnas de x).

![Fuente: http://rstudio-pubs-static.s3.amazonaws.com/227171_618ebdce0b9d44f3af65700e833593db.html](./imgs/joins.png)



Para utilizar estas funciones, vamos a tener que explicitar:

+ qué dataframes queremos unir.

+ cuál (o cuáles) es (son) la(s) columna(s) con la información correspondiente al identificador.


## inner_join()

Vamos a trabajar con la unión de tablas intentando responder la siguiente pregunta: si considerásemos a las personas amas de casa como económicamente activas, ¿cómo se modifican las tasas de actividad de varones y mujeres? 

```{r}
 base <- eph::get_microdata(year = 2019, 
                            trimester = 1, 
                            type = "individual", 
                            destfile = "clase4/eph_2019_T1.rds") %>%  
  select(CODUSU, NRO_HOGAR,"SEXO" = CH04, ESTADO, CAT_INAC, CAT_OCUP, "DESC_JUBILATORIO" = PP07H, PONDERA) %>% 
  
  mutate(SEXO = case_when(SEXO == 1 ~ "Varones",
                          SEXO == 2 ~ "Mujeres"),
         
         ESTADO = case_when(ESTADO == 1 ~ "Ocupado",
                            ESTADO == 2 ~ "Desocupado",
                            ESTADO == 3 ~ "Inactivo",
                            ESTADO == 4 ~ "Menor de 10 años"),
         
         CAT_INAC = case_when(CAT_INAC == 4 ~ "Ama de casa",
                              TRUE ~ "Otro"),
         
         CAT_OCUP = case_when(CAT_OCUP == 1 ~ "Patrón",
                            CAT_OCUP == 2 ~ "Cuenta propia",
                            CAT_OCUP == 3 ~ "Empleado",
                            CAT_OCUP == 4 ~ "TFSR"),
         
         DESC_JUBILATORIO = case_when(DESC_JUBILATORIO == 1 ~ "Tiene descuento jubilatorio",
                          DESC_JUBILATORIO == 2 ~ "No tiene descuento jubilatorio"))

```

Para responder esta pregunta, primero vamos a calcular normalmente la tasa de actividad en nuestra tabla 1:

```{r}
tabla_1 <- base %>% 
  group_by(SEXO) %>% 
  summarise(PEA = sum(PONDERA[ESTADO == "Desocupado"| ESTADO == "Ocupado"], na.rm = TRUE),
            Poblacion = sum(PONDERA),
            "Tasa de actividad" = round((PEA/Poblacion)*100,1)) %>% 
  select(-PEA,-Poblacion) 

head(tabla_1)

```

Luego, vamos a calcularla clasificando a las amas de casa como parte de la población económicamente activa en nuestra tabla 2:

```{r}
tabla_2 <- base %>% 
  mutate(ESTADO_corregido = case_when(ESTADO == "Inactivo" & CAT_INAC == "Ama de casa" ~ "Ocupado",
                                      TRUE ~ paste0(ESTADO))) %>% 
  group_by(SEXO) %>% 
  summarise(PEA = sum(PONDERA[ESTADO_corregido == "Desocupado"| ESTADO_corregido == "Ocupado"], na.rm = TRUE),
            Poblacion = sum(PONDERA),
            "Tasa de actividad corregida" = round((PEA/Poblacion)*100,1)) %>% 
  select(-PEA,-Poblacion) 

head(tabla_2)

```

Ahora, vamos a unir las tablas y calcular la diferencia:

```{r}
inner_join(tabla_1,tabla_2,by = "SEXO") %>% 
  mutate(Diferencia = `Tasa de actividad corregida` - `Tasa de actividad`)
```

Ambas filas de la tabla se encontraban presentes en la tabla 1 y la tabla 2, por lo tanto, conservamos todas las filas de ambas tablas. Como resultado, tenemos que, dado que las mujeres tienden a dedicarse en mayor medida que los varones al trabajo doméstico no remunerado, el incremento en la tasa de actividad femenina al hacer esta corrección es de 10 puntos porcentuales más que en el caso de los Varones.

## left_join() y right_join()

Pasemos a pensar en otras dimensiones de la inserción laboral de las personas de cada sexo, ¿qué proporción de las y los ocupados puede identificarse en cada categoría ocupacional? (tabla 1)

Entre quienes se encuentran en relación de dependencia, ¿la proporción de personas con descuento jubilatorio es la misma? (tabla 2)


```{r}
tabla_1 <-  base %>% 
  filter(ESTADO == "Ocupado") %>% 
  group_by(SEXO, CAT_OCUP) %>% 
  summarise(Casos = sum(PONDERA)) %>% 
  ungroup() %>% 
  group_by(SEXO) %>% 
  mutate(Total = sum(Casos),
         "Frecuencia relativa" = round((Casos/Total)*100,1)) %>% 
  select(-Casos, -Total)

head(tabla_1)

```

```{r}

tabla_2 <- base %>% 
  filter(ESTADO == "Ocupado" & CAT_OCUP == "Empleado") %>% 
  group_by(SEXO, CAT_OCUP, DESC_JUBILATORIO) %>% 
  summarise(Casos = sum(PONDERA)) %>% 
  ungroup() %>% 
  group_by(SEXO, CAT_OCUP) %>% 
  mutate(Total = sum(Casos),
         "Frecuencia relativa" = round((Casos/Total)*100,1)) %>% 
  select(-Casos, -Total) %>% 
  pivot_wider(.,id_cols = c(SEXO, CAT_OCUP), names_from = DESC_JUBILATORIO, values_from = "Frecuencia relativa")

head(tabla_2)

```


Ahora que tenemos toda la información, podemos presentarla de dos formas:

+ O bien agregando la información respecto al descuento jubilatorio a la distribución por categoría ocupacional:

```{r}
left_join(tabla_1,tabla_2, by = c("SEXO","CAT_OCUP"))
```

De este modo, permitimos un análisis más detallado de la distribución al caracterizar de forma más precisa a quienes se emplean en relación de dependencia.

+ O bien enfocando el análisis en la población en relación de dependencia, pero manteniendo el dato que da cuenta de la proporción de la población ocupada total que representan las personas que se insertan laboralmente de esta forma:

```{r}
right_join(tabla_1,tabla_2, by = c("SEXO","CAT_OCUP"))
```

De este modo, nos enfocamos en los y las asalariadas, sin olvidar que hay otro 20-30% de la población que no estamos teniendo en cuenta.

## Problemas de duplicación

Para cerrar esta sección, señalamos un problema que puede surgir al unir bases.

Imaginemos que en el cálculo de la tabla 2 generábamos la siguiente tabla (sin pivot!):

```{r}
tabla_2 <- base %>% 
  filter(ESTADO == "Ocupado" & CAT_OCUP == "Empleado") %>% 
  group_by(SEXO, CAT_OCUP, DESC_JUBILATORIO) %>% 
  summarise(Casos = sum(PONDERA)) %>% 
  ungroup() %>% 
  group_by(SEXO, CAT_OCUP) %>% 
  mutate(Total = sum(Casos),
         "Frecuencia relativa" = round((Casos/Total)*100,1)) %>% 
  select(-Casos, -Total) 

head(tabla_2)

```

Y luego aplicábamos la misma unión:

```{r}
left_join(tabla_1,tabla_2, by = c("SEXO","CAT_OCUP"))
```

¿Qué pasó? Ahora el dato de proporción de Varones/Mujeres empleados aparece duplicado. 

¿Por qué? 

Porque a cada combinación de las variables identificadoras (SEXO y CAT_OCUP) les correspondía más de una fila en la tabla 2.

¿Cómo lo solucionamos? 

La solución no es la misma en todos los casos (¡a veces lo que hay detrás de la duplicación es un error conceptual! ¿estábamos intentando generar un objeto que tiene sentido?). 

Una de las herramientas que pueden ayudarnos es la función **unique()**, que al aplicarse a un objeto (vector, dataframe, etc.) nos lo devuelve sin duplicaciones. Por ejemplo:

```{r}

left_join(tabla_1,tabla_2, by = c("SEXO","CAT_OCUP")) %>% 
  select("SEXO","CAT_OCUP")


left_join(tabla_1,tabla_2, by = c("SEXO","CAT_OCUP")) %>% 
  select("SEXO","CAT_OCUP") %>% 
  unique()

```


# Trabajo con fechas

Tenemos tres tipos de variables de tiempo principales en R:

+ **Date**: (Sólo Año, Mes y Día).

+ **Time**: (Un horario, sin especificar de que día es).

+ **Date-time**: (Año, Mes, Día y horario).

## lubridate

Es un paquete que está hecho para hacer más fácil el trabajo con fechas y horarios. Algunas de sus funcionalidades principales son:

+ Construir variables de tipo fecha a partir de números o caracteres.

+ Extraer información de variables ya constituídas como fechas.

+ Realizar operatorias con fechas (ej: calculo de distancias temporales entre dos registros).

```{r}
library(lubridate)
```


Para ver todo lo que ofrece, consultar: https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf

### Construcción de variables tipo fecha

```{r}
fecha_1 <- "30 de abril 2021"

class(fecha_1)
```
Mediante la combinacion de los caracteres dmy_hms que representan a día(d), mes(m), año(y), hora(h), minuto(m) y segundo(s) podemos convertir un número (o un string) hacia una fecha.

```{r}
fecha_1_formato <- dmy(fecha_1)

fecha_1_formato

class(fecha_1_formato)
```
También podría crear una fecha con horas, minutos y segundos:

```{r}
fecha_2 <- "2020/08/04 13:40:43"

fecha_2 <- ymd_hms(fecha_2)

fecha_2
```

Y para formatos menos estandarizados, se puede usar la función parse_date_time():

```{r}
fecha_3 <- c("Oct 1980 4", "May 1980 20", "Feb 1980 15")

fecha_3 <-parse_date_time(fecha_3, orders = "myd")

fecha_3

```

### Operaciones con fechas

Podemos calcular la cantidad de tiempo que pasó entre dos fechas:

```{r}
fecha_3[1] - fecha_3[2] 
```
¿Cuántos segundos hay en 5 semanas?

```{r}
p_5_semanas <- period(5, units = "weeks")

period_to_seconds(p_5_semanas)

```
En 5 semanas, ¿qué día es?

```{r}
now() + p_5_semanas
```


Podemos agregarle días, meses, o años a una fecha:

```{r}

fecha_2

fecha_2 + days(4)

fecha_2 + years(10)

```

### Extraer información de fechas

A veces, queremos extraer algún elemento de la fecha para procesar a información.


```{r}

#Número
month(fecha_2)

#O nombre
month(fecha_2, label = T)
```

```{r}
wday(fecha_2, label = T)
```

Ejemplo: tomamos la base del Ministerio de Justicia y Derechos Humanos de la Línea 137 - víctimas de violencia familiar - llamados e intervenciones domiciliarias. Cada fila del registro es un caso.

```{r}
library(readxl)

llamados_atendidos_violencia_familiar_202202 <- read_excel("clase4/llamados-atendidos-violencia-familiar-202202.xlsx") 

```

¿En qué día de la semana se llama más?

```{r}
llamados_atendidos_violencia_familiar_202202 %>% 
  mutate(dia = wday(llamado_fecha, label = T)) %>% 
  group_by(dia) %>% 
  summarise(Casos = n()) %>% 
  arrange(-Casos)
```


# Exportar resultados

Los objetos que creamos en el entorno de R existen en es entorno de R y al cerrar la sesión, desaparecen. Sin embargo, podemos querer guardar algún resultado. A estos fines, podemos recurrir a las herramientas para exportar a excel nuestros resultados.

El comando más simple para hacer esto es write.xlsx()

```{r}
write.xlsx(tabla_1, file = "clase4/prueba1.xlsx")
```

Para guardar varios elementos en un mismo excel en distintas pestañas, recurrimos a una lista, donde indicamos para cada elemento que queramos guardar "Nombre de la pestaña" = Objeto de R.

```{r}
write.xlsx(list("resultado_cat_ocup"=tabla_1 ,
                "resultado_desc_jub"=tabla_2), 
           file = "clase4/prueba1.xlsx")
```


¡Terminamos! Ahora, vamos a la parte práctica. 